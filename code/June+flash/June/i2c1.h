//===============================================================================================
//    		 Подключение к выводам МК, задержки
//===============================================================================================
#define SDA1			6		// ножка данных, SDA1
#define SCL1			7		// ножка тактирования, SCL1
#define I2C_PORT	PORTA	// Тут указать порт, например PORTB или PORTC
#define I2C_PIN		PINA	// Тут указать порт, например PINB или PINC
#define I2C_DDR		DDRA	// Тут указать порт, например DDRB или DDRC
// все задержки при работе шины i2c, изменяйте это число только если знаете, что делаете!!!
#define I2C_DELAY	_delay_us(10); // по умолчанию задержки 10 микросекунд (частота работы 1/10us = 100кГц)
























//===============================================================
//               Служебные переменные и библиотеки
//===============================================================
#include <util/delay.h>
volatile unsigned char i2c_frame_error1=0; // если > 0, значит произошла фрейм-ошибка (после STOP-команды, линии SDA1 и SCL1 не перешли в состояние HIGH, не подтянулись к + питания)







//*************************************************************
//ПРОТОТИПЫ ФУНКЦИЙ
void i2c_init1 (void);									// настраивает выводы микроконтроллера
void i2c_start_cond1 (void);								// генерирует условие старта
void i2c_restart_cond1 (void);							// генерирует условие повторного старта
void i2c_stop_cond1 (void);								// генерирует условие стоп
unsigned char i2c_send_byte1 (unsigned char data);		// возвращает ACK, если = 1 значит данные переданы неуспешно, если = 0 значит данные переданы успешно, data это передаваемый байт
unsigned char i2c_get_byte1 (unsigned char last_byte);	// возвращает считанный байт, last_byte = 1 означает что считываем последний байт, last_byte = 0 означает что будем считывать ещё байт












//===============================================================
//                   Генерация условия стоп
//===============================================================
void i2c_stop_cond1 (void)	{
	I2C_DDR |= _BV(SCL1); // притянуть SCL1 (лог.0)
	I2C_DELAY
	I2C_DDR |= _BV(SDA1); // притянуть SDA1 (лог.0)
	I2C_DELAY
		
	I2C_DDR &= ~_BV(SCL1); // отпустить SCL1 (лог.1)
	I2C_DELAY
	I2C_DDR &= ~_BV(SDA1); // отпустить SDA1 (лог.1)
	I2C_DELAY
	
	// проверка фрейм-ошибки
	i2c_frame_error1=0;									// сброс счётчика фрейм-ошибок
	if ((I2C_PIN & _BV(SDA1)) == 0) i2c_frame_error1++;	// проберяем, чтобы на ноге SDA1 была лог.1, иначе выдаём ошибку фрейма
	if ((I2C_PIN & _BV(SCL1)) == 0) i2c_frame_error1++;	// проберяем, чтобы на ноге SCL1 была лог.1, иначе выдаём ошибку фрейма
	I2C_DELAY
	I2C_DELAY
	I2C_DELAY
	I2C_DELAY
}







//===============================================================
//                    инициализация шины I2C
//===============================================================
void i2c_init1 (void) {
	////////для I2C/////////
	I2C_DDR &= ~_BV(SDA1);		// когда DDR=0, вывод SDA1 висит в воздухе, когда DDR=1 то SDA1 притянута к земле (регистром DDR мы и будем манипулировать)
	I2C_DDR &= ~_BV(SCL1);		// когда DDR=0, вывод SCL1 висит в воздухе, когда DDR=1 то SCL1 притянута к земле (регистром DDR мы и будем манипулировать)
	I2C_PORT &= ~_BV(SDA1);      // PORT=0 означает, что когда DDR=1 то SDA1 притянута к земле, когда DDR=0, то SDA1 висит в воздухе
	I2C_PORT &= ~_BV(SCL1);      // PORT=0 означает, что когда DDR=1 то SCL1 притянута к земле, когда DDR=0, то SCL1 висит в воздухе
	i2c_stop_cond1();   // стоп шины на случай сбоев
	i2c_stop_cond1();   // стоп шины на случай сбоев
}






//===============================================================
//                    Генерация условия старт
//===============================================================
void i2c_start_cond1 (void)	{	
	I2C_DDR |= _BV(SDA1); // притянуть SDA1 (лог.0)
	I2C_DELAY
	I2C_DDR |= _BV(SCL1); // притянуть SCL1 (лог.0)
	I2C_DELAY
}








//===============================================================
//      Генерация условия рестарт
//===============================================================
void i2c_restart_cond1 (void)	{	
	I2C_DDR &= ~_BV(SDA1); // отпустить SDA1 (лог.1)
	I2C_DELAY
	I2C_DDR &= ~_BV(SCL1); // отпустить SCL1 (лог.1)
	I2C_DELAY
	
	I2C_DDR |= _BV(SDA1); // притянуть SDA1 (лог.0)
	I2C_DELAY
	I2C_DDR |= _BV(SCL1); // притянуть SCL1 (лог.0)
	I2C_DELAY
}






                   
//===============================================================
//                    Отправка байта по I2С
//===============================================================
unsigned char i2c_send_byte1 (unsigned char data)	{	
 unsigned char i;
 unsigned char ack=1;			//АСК, если АСК=1 – произошла ошибка
	for (i=0;i<8;i++)
	{
		if ((data&0x80)==0x00) I2C_DDR |= _BV(SDA1);	// Выставить бит на SDA1 (лог.0)
		else I2C_DDR &= ~_BV(SDA1); // лог.1
		I2C_DELAY
		I2C_DDR &= ~_BV(SCL1);	// Записать его импульсом на SCL1       // отпустить SCL1 (лог.1)
		I2C_DELAY
		I2C_DDR |= _BV(SCL1); // притянуть SCL1 (лог.0)
		data=data<<1;
	}
	I2C_DDR &= ~_BV(SDA1); // отпустить SDA1 (лог.1), чтобы ведомое устройство смогло сгенерировать ACK
	I2C_DELAY
	I2C_DDR &= ~_BV(SCL1); // отпустить SCL1 (лог.1), чтобы ведомое устройство передало ACK
	I2C_DELAY
	if ((I2C_PIN&_BV(SDA1))==_BV(SDA1)) ack=1; else ack=0;	// Считать ACK

	I2C_DDR |= _BV(SCL1); // притянуть SCL1 (лог.0)  // приём ACK завершён
	
	return ack; // вернуть ACK (0) или NACK (1)
}






//===============================================================
//                   Считывание байта по I2C
//===============================================================
unsigned char i2c_get_byte1 (unsigned char last_byte)	{	
 unsigned char i, res=0;
	I2C_DDR &= ~_BV(SDA1); // отпустить SDA1 (лог.1)

	for (i=0;i<8;i++)
	{
		res=res<<1;
		I2C_DDR &= ~_BV(SCL1); // отпустить SCL1 (лог.1)		//Импульс на SCL1
		I2C_DELAY
		if ((I2C_PIN&_BV(SDA1))==_BV(SDA1)) res=res|0x01; // Чтение SDA1 в переменную
		I2C_DDR |= _BV(SCL1); // притянуть SCL1 (лог.0)
		I2C_DELAY
	}

	if (last_byte==0) I2C_DDR |= _BV(SDA1); // притянуть SDA1 (лог.0)		// Подтверждение, ACK, будем считывать ещё один байт
	else I2C_DDR &= ~_BV(SDA1); // отпустить SDA1 (лог.1)					// Без подтверждения, NACK, это последний считанный байт
	I2C_DELAY
	I2C_DDR &= ~_BV(SCL1); // отпустить SCL1 (лог.1)
	I2C_DELAY
	I2C_DDR |= _BV(SCL1); // притянуть SCL1 (лог.0)
	I2C_DELAY
	I2C_DDR &= ~_BV(SDA1); // отпустить SDA1 (лог.1)

	return res; // вернуть считанное значение
}









